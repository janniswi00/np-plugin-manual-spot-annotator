"""
This module contains four napari widgets declared in
different ways:

- a pure Python function flagged with `autogenerate: true`
    in the plugin manifest. Type annotations are used by
    magicgui to generate widgets for each parameter. Best
    suited for simple processing tasks - usually taking
    in and/or returning a layer.
- a `magic_factory` decorated function. The `magic_factory`
    decorator allows us to customize aspects of the resulting
    GUI, including the widgets associated with each parameter.
    Best used when you have a very simple processing task,
    but want some control over the autogenerated widgets. If you
    find yourself needing to define lots of nested functions to achieve
    your functionality, maybe look at the `Container` widget!
- a `magicgui.widgets.Container` subclass. This provides lots
    of flexibility and customization options while still supporting
    `magicgui` widgets and convenience methods for creating widgets
    from type annotations. If you want to customize your widgets and
    connect callbacks, this is the best widget option for you.
- a `QWidget` subclass. This provides maximal flexibility but requires
    full specification of widget layouts, callbacks, events, etc.

References:
- Widget specification: https://napari.org/stable/plugins/guides.html?#widgets
- magicgui docs: https://pyapp-kit.github.io/magicgui/

Replace code below according to your needs.
"""

from typing import TYPE_CHECKING

import numpy as np
import pandas as pd
from qtpy.QtWidgets import (
    QLineEdit,
    QListWidget,
    QPushButton,
    QVBoxLayout,
    QWidget,
)

if TYPE_CHECKING:
    import napari


from napari.layers import Points
from qtpy.QtWidgets import QFileDialog


class ExampleQWidget(QWidget):
    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self.viewer = viewer

        # Button zum Starten/Stoppen des Annotierungsmodus
        self.annotation_button = QPushButton("Annotate Spots")
        self.annotation_button.setCheckable(True)
        self.annotation_button.clicked.connect(self._toggle_annotation_mode)

        # Liste der annotierten Spots
        self.spot_list_widget = QListWidget()
        self.spot_list_widget.itemClicked.connect(
            self._highlight_spot_in_viewer
        )

        # Eingabefeld für Text
        self.text_input = QLineEdit()
        self.text_input.setPlaceholderText("Enter annotation text...")
        self.text_input.returnPressed.connect(
            self._add_text_to_spot
        )  # Enter bestätigt Text

        # Button zum Löschen des ausgewählten Spots
        self.delete_button = QPushButton("Delete Selected Spot")
        self.delete_button.clicked.connect(self._delete_selected_spot)

        # Button zum Exportieren der Spots
        self.export_button = QPushButton("Export to CSV")
        self.export_button.clicked.connect(self._export_to_csv)

        # Layout einrichten
        layout = QVBoxLayout()
        layout.addWidget(self.annotation_button)
        layout.addWidget(self.spot_list_widget)
        layout.addWidget(self.text_input)
        layout.addWidget(self.delete_button)
        layout.addWidget(self.export_button)
        self.setLayout(layout)

        # Annotationsebene und Status
        self.annotation_layer: Points = None
        self.annotating = False
        self.annotations = []  # Liste für Koordinaten und Texte

    def _toggle_annotation_mode(self):
        """Schaltet den Annotierungsmodus um."""
        self.annotating = not self.annotating
        if self.annotating:
            self.annotation_button.setText("Stop Annotating")
            self.viewer.mouse_drag_callbacks.append(self._add_annotation)
            self._setup_annotation_layer()
        else:
            self.annotation_button.setText("Annotate Spots")
            self.viewer.mouse_drag_callbacks.remove(self._add_annotation)

    def _setup_annotation_layer(self):
        """Erstellt eine Annotationsebene, falls sie noch nicht existiert."""
        if self.annotation_layer is None:
            self.annotation_layer = self.viewer.add_points(
                np.empty((0, 2)),  # Nur X und Y
                name="Spot Annotations",
                size=8,  # Standardgröße
                border_width=0.05,  # Relativ und < 1
                border_color=[0, 0, 1, 1],  # Blau in RGBA
                face_color=[0, 0, 0, 0],  # Transparent in RGBA
            )

    def _add_annotation(self, viewer, event):
        """Fügt einen Spot an der aktuellen Position des Cursors hinzu."""
        if not self.annotating:
            return

        # Cursorposition abrufen (X, Y, Z, Kanal etc.)
        cursor_position = np.array(viewer.cursor.position)

        # Nur X und Y verwenden
        coords = cursor_position[2:]

        # Spot zur Punkteebene hinzufügen
        self.annotation_layer.data = np.vstack(
            [self.annotation_layer.data, coords]
        )

        # Annotation ohne Text hinzufügen
        self.annotations.append({"x": coords[0], "y": coords[1], "text": ""})
        self._update_spot_list()

    def _update_spot_list(self):
        """Aktualisiert die Liste der annotierten Spots."""
        self.spot_list_widget.clear()
        for i, annotation in enumerate(self.annotations, start=1):
            text = annotation["text"] if annotation["text"] else "No text"
            self.spot_list_widget.addItem(
                f"Spot {i}: (X={annotation['x']:.2f}, Y={annotation['y']:.2f}) - {text}"
            )

    def _highlight_spot_in_viewer(self, item):
        """Hebt den Spot im Viewer hervor, der in der Liste angeklickt wurde."""
        # Hole den Index des ausgewählten Listenelements
        index = self.spot_list_widget.row(item)
        if index < 0 or index >= len(self.annotation_layer.data):
            return

        # Setze die Farben aller Spots zurück
        default_color = [0, 0, 1, 1]  # Blau in RGBA
        self.annotation_layer.border_color = np.array(
            [default_color] * len(self.annotation_layer.data)
        )

        # Ändere die Farbe des ausgewählten Spots auf Rot
        self.annotation_layer.border_color[index] = [1, 0, 0, 1]  # Rot in RGBA

        self.annotation_layer.refresh()

    def _add_text_to_spot(self):
        """Fügt dem ausgewählten Spot einen Text hinzu."""
        selected_items = self.spot_list_widget.selectedItems()
        if not selected_items:
            return

        selected_item = selected_items[0]
        index = self.spot_list_widget.row(selected_item)

        # Text hinzufügen
        text = self.text_input.text()
        if text:
            self.annotations[index]["text"] = text
            self._update_spot_list()
            self.text_input.clear()

    def _delete_selected_spot(self):
        """Löscht den aktuell in der Liste ausgewählten Spot."""
        selected_items = self.spot_list_widget.selectedItems()
        if not selected_items:
            return

        selected_item = selected_items[0]
        index = self.spot_list_widget.row(selected_item)

        # Lösche den Spot aus der Ebene und den Annotationen
        self.annotation_layer.data = np.delete(
            self.annotation_layer.data, index, axis=0
        )
        del self.annotations[index]

        # Liste aktualisieren
        self._update_spot_list()

    def _export_to_csv(self):
        """Exportiert die annotierten Spots in eine CSV-Datei."""
        filename, _ = QFileDialog.getSaveFileName(
            self, "Save Annotations", "", "CSV Files (*.csv)"
        )
        if filename:
            df = pd.DataFrame(self.annotations)
            df.to_csv(filename, index=False)
            print(f"Annotations exported to {filename}")
