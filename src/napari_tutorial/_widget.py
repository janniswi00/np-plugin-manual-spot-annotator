"""
This module contains four napari widgets declared in
different ways:

- a pure Python function flagged with `autogenerate: true`
    in the plugin manifest. Type annotations are used by
    magicgui to generate widgets for each parameter. Best
    suited for simple processing tasks - usually taking
    in and/or returning a layer.
- a `magic_factory` decorated function. The `magic_factory`
    decorator allows us to customize aspects of the resulting
    GUI, including the widgets associated with each parameter.
    Best used when you have a very simple processing task,
    but want some control over the autogenerated widgets. If you
    find yourself needing to define lots of nested functions to achieve
    your functionality, maybe look at the `Container` widget!
- a `magicgui.widgets.Container` subclass. This provides lots
    of flexibility and customization options while still supporting
    `magicgui` widgets and convenience methods for creating widgets
    from type annotations. If you want to customize your widgets and
    connect callbacks, this is the best widget option for you.
- a `QWidget` subclass. This provides maximal flexibility but requires
    full specification of widget layouts, callbacks, events, etc.

References:
- Widget specification: https://napari.org/stable/plugins/guides.html?#widgets
- magicgui docs: https://pyapp-kit.github.io/magicgui/

Replace code below according to your needs.
"""

from typing import TYPE_CHECKING

import numpy as np
import pandas as pd
from magicgui import magic_factory
from magicgui.widgets import CheckBox, Container, create_widget
from qtpy.QtWidgets import (
    QLineEdit,
    QListWidget,
    QPushButton,
    QVBoxLayout,
    QWidget,
)
from skimage.util import img_as_float

if TYPE_CHECKING:
    import napari


from napari.layers import Points
from qtpy.QtWidgets import QFileDialog


# Uses the `autogenerate: true` flag in the plugin manifest
# to indicate it should be wrapped as a magicgui to autogenerate
# a widget.
def threshold_autogenerate_widget(
    img: "napari.types.ImageData",
    threshold: "float",
) -> "napari.types.LabelsData":
    return img_as_float(img) > threshold


# the magic_factory decorator lets us customize aspects of our widget
# we specify a widget type for the threshold parameter
# and use auto_call=True so the function is called whenever
# the value of a parameter changes
@magic_factory(
    threshold={"widget_type": "FloatSlider", "max": 1}, auto_call=True
)
def threshold_magic_widget(
    img_layer: "napari.layers.Image", threshold: "float"
) -> "napari.types.LabelsData":
    return img_as_float(img_layer.data) > threshold


# if we want even more control over our widget, we can use
# magicgui `Container`
class ImageThreshold(Container):
    def __init__(self, viewer):  # ":napari.viewer.Viewer"
        super().__init__()
        self._viewer = viewer
        # use create_widget to generate widgets from type annotations
        self._image_layer_combo = create_widget(
            label="Image", annotation="napari.layers.Image"
        )
        self._threshold_slider = create_widget(
            label="Threshold", annotation=float, widget_type="FloatSlider"
        )
        self._threshold_slider.min = 0
        self._threshold_slider.max = 1
        # use magicgui widgets directly
        self._invert_checkbox = CheckBox(text="Keep pixels below threshold")

        # connect your own callbacks
        self._threshold_slider.changed.connect(self._threshold_im)
        self._invert_checkbox.changed.connect(self._threshold_im)

        # append into/extend the container with your widgets
        self.extend(
            [
                self._image_layer_combo,
                self._threshold_slider,
                self._invert_checkbox,
            ]
        )

    def _threshold_im(self):
        image_layer = self._image_layer_combo.value
        if image_layer is None:
            return

        image = img_as_float(image_layer.data)
        name = image_layer.name + "_thresholded"
        threshold = self._threshold_slider.value
        if self._invert_checkbox.value:
            thresholded = image < threshold
        else:
            thresholded = image > threshold
        if name in self._viewer.layers:
            self._viewer.layers[name].data = thresholded
        else:
            self._viewer.add_labels(thresholded, name=name)


# class ExampleQWidget(QWidget):
#     # your QWidget.__init__ can optionally request the napari viewer instance
#     # use a type annotation of 'napari.viewer.Viewer' for any parameter
#     def __init__(self, viewer: "napari.viewer.Viewer"):
#         super().__init__()
#         self.viewer = viewer

#         btn = QPushButton("Click me!")
#         btn.clicked.connect(self._on_click)

#         self.setLayout(QHBoxLayout())
#         self.layout().addWidget(btn)

#     def _on_click(self):
#         print("napari has", len(self.viewer.layers), "layers")


class ExampleQWidget(QWidget):
    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self.viewer = viewer

        # Button zum Starten/Stoppen des Annotierungsmodus
        self.annotation_button = QPushButton("Annotate Spots")
        self.annotation_button.setCheckable(True)
        self.annotation_button.clicked.connect(self._toggle_annotation_mode)

        # Liste der annotierten Spots
        self.spot_list_widget = QListWidget()
        self.spot_list_widget.itemClicked.connect(
            self._highlight_spot_in_viewer
        )

        # Eingabefeld für Text
        self.text_input = QLineEdit()
        self.text_input.setPlaceholderText("Enter annotation text...")
        self.text_input.returnPressed.connect(
            self._add_text_to_spot
        )  # Enter bestätigt Text

        # Button zum Löschen des ausgewählten Spots
        self.delete_button = QPushButton("Delete Selected Spot")
        self.delete_button.clicked.connect(self._delete_selected_spot)

        # Button zum Exportieren der Spots
        self.export_button = QPushButton("Export to CSV")
        self.export_button.clicked.connect(self._export_to_csv)

        # Layout einrichten
        layout = QVBoxLayout()
        layout.addWidget(self.annotation_button)
        layout.addWidget(self.spot_list_widget)
        layout.addWidget(self.text_input)
        layout.addWidget(self.delete_button)
        layout.addWidget(self.export_button)
        self.setLayout(layout)

        # Annotationsebene und Status
        self.annotation_layer: Points = None
        self.annotating = False
        self.annotations = []  # Liste für Koordinaten und Texte

    def _toggle_annotation_mode(self):
        """Schaltet den Annotierungsmodus um."""
        self.annotating = not self.annotating
        if self.annotating:
            self.annotation_button.setText("Stop Annotating")
            self.viewer.mouse_drag_callbacks.append(self._add_annotation)
            self._setup_annotation_layer()
        else:
            self.annotation_button.setText("Annotate Spots")
            self.viewer.mouse_drag_callbacks.remove(self._add_annotation)

    def _setup_annotation_layer(self):
        """Erstellt eine Annotationsebene, falls sie noch nicht existiert."""
        if self.annotation_layer is None:
            self.annotation_layer = self.viewer.add_points(
                np.empty((0, 2)),  # Nur X und Y
                name="Spot Annotations",
                size=8,  # Standardgröße
                border_width=0.05,  # Relativ und < 1
                border_color=[0, 0, 1, 1],  # Blau in RGBA
                face_color=[0, 0, 0, 0],  # Transparent in RGBA
            )

    def _add_annotation(self, viewer, event):
        """Fügt einen Spot an der aktuellen Position des Cursors hinzu."""
        if not self.annotating:
            return

        # Cursorposition abrufen (X, Y, Z, Kanal etc.)
        cursor_position = np.array(viewer.cursor.position)

        # Nur X und Y verwenden
        coords = cursor_position[2:]

        # Spot zur Punkteebene hinzufügen
        self.annotation_layer.data = np.vstack(
            [self.annotation_layer.data, coords]
        )

        # Annotation ohne Text hinzufügen
        self.annotations.append({"x": coords[0], "y": coords[1], "text": ""})
        self._update_spot_list()

    def _update_spot_list(self):
        """Aktualisiert die Liste der annotierten Spots."""
        self.spot_list_widget.clear()
        for i, annotation in enumerate(self.annotations, start=1):
            text = annotation["text"] if annotation["text"] else "No text"
            self.spot_list_widget.addItem(
                f"Spot {i}: (X={annotation['x']:.2f}, Y={annotation['y']:.2f}) - {text}"
            )

    def _highlight_spot_in_viewer(self, item):
        """Hebt den Spot im Viewer hervor, der in der Liste angeklickt wurde."""
        # Hole den Index des ausgewählten Listenelements
        index = self.spot_list_widget.row(item)
        if index < 0 or index >= len(self.annotation_layer.data):
            return

        # Setze die Farben aller Spots zurück
        default_color = [0, 0, 1, 1]  # Blau in RGBA
        self.annotation_layer.border_color = np.array(
            [default_color] * len(self.annotation_layer.data)
        )

        # Ändere die Farbe des ausgewählten Spots auf Rot
        self.annotation_layer.border_color[index] = [1, 0, 0, 1]  # Rot in RGBA

        self.annotation_layer.refresh()

    def _add_text_to_spot(self):
        """Fügt dem ausgewählten Spot einen Text hinzu."""
        selected_items = self.spot_list_widget.selectedItems()
        if not selected_items:
            return

        selected_item = selected_items[0]
        index = self.spot_list_widget.row(selected_item)

        # Text hinzufügen
        text = self.text_input.text()
        if text:
            self.annotations[index]["text"] = text
            self._update_spot_list()
            self.text_input.clear()

    def _delete_selected_spot(self):
        """Löscht den aktuell in der Liste ausgewählten Spot."""
        selected_items = self.spot_list_widget.selectedItems()
        if not selected_items:
            return

        selected_item = selected_items[0]
        index = self.spot_list_widget.row(selected_item)

        # Lösche den Spot aus der Ebene und den Annotationen
        self.annotation_layer.data = np.delete(
            self.annotation_layer.data, index, axis=0
        )
        del self.annotations[index]

        # Liste aktualisieren
        self._update_spot_list()

    def _export_to_csv(self):
        """Exportiert die annotierten Spots in eine CSV-Datei."""
        filename, _ = QFileDialog.getSaveFileName(
            self, "Save Annotations", "", "CSV Files (*.csv)"
        )
        if filename:
            df = pd.DataFrame(self.annotations)
            df.to_csv(filename, index=False)
            print(f"Annotations exported to {filename}")
